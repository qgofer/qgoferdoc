# AUTOGENERATED! DO NOT EDIT! File to edit: ..\nbs\02_manage_index.ipynb.

# %% auto 0
__all__ = ['Q', 'DOC_CACHE', 'create_documents_cache', 'RAKE']

# %% ..\nbs\02_manage_index.ipynb 5
from qgoferutils.config import QGoferConfig
from qgoferutils.db import QGoferDBWrapper

Q = QGoferConfig()
DOC_CACHE = "qgofer_documents_cache"

# %% ..\nbs\02_manage_index.ipynb 6
def create_documents_cache(self) -> None:
    """Create the qgofer documents cache database."""
    qgofer_db_wrapper = QGoferDBWrapper(Q.qgofer_cache_db)
    qgofer_db_wrapper.create_table(
        f"{DOC_CACHE}", "key_words TEXT,a_time REAL,m_time REAL,c_time REAL,file_size REAL,file TEXT UNIQUE"
    )

def _clear_cache_db(self) -> None:
    """Clear the qgofer cache database."""
    qgofer_db_wrapper = QGoferDBWrapper(Q.qgofer_cache_db)
    qgofer_db_wrapper.drop_table(f"{DOC_CACHE}")

# %% ..\nbs\02_manage_index.ipynb 7
#| export



# %% ..\nbs\02_manage_index.ipynb 8
class RAKE:
    """Rapid Automatic Keyword Extraction algorithm."""

    def __init__(self, stop_words_file: str = ''):
        """Initialize the RAKE object."""
        self.stop_words_file_path = stop_words_file
        self.stop_words_pattern = build_stop_word_regex(stop_words_file)

    def exec(self, text: str):
        """Execute the RAKE algorithm."""
        sentences = self.split_sentences(text)
        phrases = self.generate_candidate_keywords(sentences)
        word_scores = self.calculate_word_scores(phrases)
        keyword_candidates = self.generate_candidate_keyword_scores(phrases, word_scores)
        sorted_keywords = sorted(keyword_candidates.items(), key=operator.itemgetter(1), reverse=True)

        return sorted_keywords

    def split_sentences(self, text: str) -> list:
        """Split text into sentences."""
        pattern = u'[.!?,;:\t\\\\"\\(\\)\\\'\u2019\u2013]|\\s\\-\\s'
        sentence_delimiters = re.compile(pattern)
        sentences = sentence_delimiters.split(text)

        return sentences

    def generate_candidate_keywords(self, sentences: list) -> list:
        """Returns keyword phrases after removing stopwords from each sentence."""
        phrases_list = []
        for sentence in sentences:
            phrases = re.sub(self.stop_words_pattern, '|', sentence.strip()).split('|')
            for phrase in phrases:
                phrase = phrase.strip().lower()
                if phrase != "":
                    phrases_list.append(phrase)

        return phrases_list

    def is_number(self, s):
        """Check if a string is a number."""
        try:
            float(s) if '.' in s else int(s)
            return True
        except ValueError:
            return False

    def separate_words(self, text: str, word_min_size: int = 0) -> list:
        """Return a list of all words of length greater than specified min size.

        Args:
            text:
                the text that is to be split into words
            word_min_size:
                the min. no. of characters a word must have (def: 0)
        """
        splitter = re.compile('[^a-zA-Z0-9_\\+\\-/]')
        words = []
        for single_word in splitter.split(text):
            current_word = single_word.strip().lower()
            if len(current_word) > word_min_size and current_word != '' and not self.is_number(current_word):
                words.append(current_word)

        return words

    def calculate_word_scores(self, phrases: list) -> dict:
        """Calculates the word score for all the words in the phrases."""
        word_frequency: Dict[Any, Any] = {}
        word_degree: Dict[Any, Any] = {}
        for phrase in phrases:
            words = self.separate_words(phrase)
            words_list_degree = len(words) - 1
            for word in words:
                word_frequency.setdefault(word, 0)
                word_frequency[word] += 1
                word_degree.setdefault(word, 0)
                word_degree[word] += words_list_degree

        for item in word_frequency:
            word_degree[item] = word_degree[item] + word_frequency[item]

        # Calculate word score = def(w) / freq(w)
        word_score = {}
        for item in word_frequency:
            # word_score.setdefault(item, 0):
            word_score[item] = word_degree[item] / (word_frequency[item] * 1.0)

        return word_score

    def generate_candidate_keyword_scores(self, phrases: list, word_score: dict) -> dict:
        """Returns the dict. of candidate keywords with scores."""
        keyword_candidates: Dict[Any, Any] = {}
        for phrase in phrases:
            keyword_candidates.setdefault(phrase, 0)
            words = self.separate_words(phrase)
            candidate_score = 0
            for word in words:
                candidate_score += word_score[word]
            keyword_candidates[phrase] = candidate_score

        return keyword_candidates
